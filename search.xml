<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我的2019年]]></title>
    <url>%2Fblog%2F2020%2F01%2F10%2Fmy_2019%2F</url>
    <content type="text"><![CDATA[我属猪，2019年是我第二个本命年。 回顾这一年，挫折不少，但我并不想归结于运气。这几年，我愈来愈抵触一切与迷信相关的事。可能正因为如此，我变得愈发现实，缺少信仰，这对我的心理也造成了影响。比如焦虑。亦或许是年龄导致的。失眠的次数增加了不少。 19年，我搬了两次家，不得不感叹独自在外租房的心酸。 之前我住的是一个小隔间，房东还刷了新漆，一直有一股挥之不去的甲醛味，房租750。好不容易熬到房租到期了，我寻了好久，找到一个不错的房子，房租1200。房东是个老太太，两室一厅的房子，她住另一间。房东表现的很热情，亲切的让我称她姑姑。本打算好好开始生活，没想到，才一个月，房东转手帮房子卖了。我想找她理论，老太太一改往日面孔，拿出当初的合同，上面全是对她有利的条款，并没有写房东违约会怎么样。我诧然，忿忿的说起自己的不满。老人竟开始两眼抹泪，诉说着女儿败家，丈夫凶恶。我只得忍气离开。所幸，在公司楼下，租到一间马马虎虎的房间。这次的房东是个年轻的姑娘，人很好，一点不虚伪。 19年我在的这家公司是一个很大的外包公司，我在里面当着一颗小小的螺丝。工作量不是很大，除了写一些小模块，就是不停地改测试提的问题单。也有忙的时候，记得有两个月搞什么冲刺，几乎每天加班到十点钟。好在离宿舍近，倒不是很辛苦。 日子就这么重复了大半年。突然有一天，项目组突然开始释放了。释放的意思就是把你调到其他项目组。周六我接到了一个面试电话，结果下周就调到另一个项目组了。在这个项目组呆了半个月，很不适应。之前的同事都很合得来，大家互相帮助。领导也不错，积极的帮我解决问题。来的第二天，项目经理走了！我的很多手续也没办好，我一头雾水，临时的项目经理也是一问三不知的状态。前端组长是个胖子，刚来的时候我不理解项目需求，他一脸不耐烦，说：“我很忙的，你去问领导去”。我找那个领导，他又让我回来找胖子。胖子把我和那个领导拉了个会议，领导对我说：“我不知道你想干嘛？”后来辗转问了很多人后，总算搞明白了真正的需求。不明白为什么大家不能好好说话呢，把需求讲清楚。非要高高在上的，就说几个字，让你猜，猜的不对，你问他还不耐烦，对你说话的态度仿佛在对一个傻x说话。如果说之前的项目组是正常的，那这个项目组就是畸形的。 这时候我已经有离职的念头了，当然这还都是次要的。不管环境怎么样，我做好自己的工作就行了，还是开心的。直到我无意中得知，刚来的一个小姑娘，薪资比我高30%。这件事对我开了最后一枪，我找项目经理离职，他一再挽留，说下个月就涨薪，你好好干，未来。。。我没有听下去，提交了离职报告，请了两周假，等待审批。公司的流程很繁琐，终于在假期的最后一天前，审批完了。 新工作离住的地方一个半小时车程，我不得不再次搬家。和林约好一起租个两室的房子。莫奈何那边地段实在太贵，找到最后简直绝望了，凑合租了一个7楼没电梯的老破小。这件事可以说是我19年最后悔的一件事了。房子看完十分钟就交了定金，然后就后悔了。搬进来更后悔，千辛万苦把我的两车行李，人工搬到了七楼，然后发现林有三车行李。房东特别抠，房子又没网，油烟机坏的，灶台脏的不能用，还有蟑螂和老鼠，水管漏水，冬天窗户还漏风，冻成狗。。。。。。 刚换工作，还没过试用期，生怕被开了。就是这段时间，我开始焦虑，每天都在后悔。但又舍不得放弃租金搬走。这就是人的损失厌恶心理，对待沉没成本无法轻易的放弃，其实就是太穷苦了。中秋回家的时候，老爸给了我五百块钱。 跨年那天晚上，我骑着小毛驴，带着林找到一家重庆鸡公煲。林看着墙上的画，咯咯咯的笑了起来：“你说咱们像不像墙上的那两个人，你是这个秃头的，哈哈哈！”我没有回答：啧啧，这家不正宗，不好吃！吃完后，在路上开了一圈有一圈，想找一个可以跨年的地方，最后没找到，还迷路了。“回家吧，这风吹的，太冷了！”林打开了导航。 12点快到了，我对林说，忍一忍吧，明年日子就好过了。林不屑一顾，你去年也是这么对我说我，每一年都这么说，骗子，我再也不相信你了。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue中实现拖拽功能]]></title>
    <url>%2Fblog%2F2019%2F11%2F12%2Fdraggable%2F</url>
    <content type="text"><![CDATA[需求很简单，拖动框框或者数字来调整顺序。如下图 一、找轮子在网上搜了一会发现一个好用的插件——vue-draggable 二、使用方法1.安装npm i -S vuedraggable2.引用import draggable from &#39;vuedraggable&#39;3.实现需求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;template&gt; &lt;div class=&quot;dragbox&quot;&gt; &lt;div class=&quot;note&quot;&gt;拖动题型或题号调整顺序&lt;/div&gt; &lt;draggable v-model=&quot;list&quot; v-bind=&quot;firstDragOptions&quot; @change=&quot;changeTitle&quot;&gt; &lt;transition-group&gt; &lt;div class=&quot;titleBox&quot; v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;firstTitle&quot;&gt;&#123;&#123;item.firstTitle&#125;&#125;&lt;/div&gt; &lt;draggable v-model=&quot;item.secondTitle&quot; @change=&quot;changeNum&quot; v-bind=&quot;secondDragOptions&quot; :group=&quot;&apos;changeNum&apos;+index&quot;&gt; &lt;transition-group&gt; &lt;div class=&quot;secondTitle&quot; v-for=&quot;(title,key) in item.secondTitle&quot; :key=&quot;key&quot;&gt; &lt;span class=&quot;num&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/transition-group&gt; &lt;/draggable&gt; &lt;/div&gt; &lt;/transition-group&gt; &lt;/draggable&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import draggable from &quot;vuedraggable&quot;;import cloneDeep from &quot;lodash/cloneDeep&quot;;export default &#123; name: &quot;DragComponent&quot;, components: &#123; draggable &#125;, props: [&quot;dragTitles&quot;], data() &#123; return &#123; list: [] &#125;; &#125;, computed: &#123; firstDragOptions() &#123; return &#123; group: &quot;changeTitle&quot;, animation: 200, disabled: false, ghostClass: &quot;ghost&quot; &#125;; &#125;, secondDragOptions() &#123; return &#123; animation: 200, disabled: false, ghostClass: &quot;ghost2&quot; &#125;; &#125; &#125;, created() &#123; this.list = cloneDeep(this.dragTitles); &#125;, methods: &#123; changeTitle(evt) &#123; console.log(&quot;this.list: &quot;, this.list); &#125;, changeNum(evt) &#123; console.log(&quot;this.list: &quot;, this.list); &#125; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.dragbox &#123; padding: 0 10px;&#125;.note &#123; color: #999999; font-size: 14px;&#125;.titleBox &#123; height: 116px; padding: 10px 20px; border: 1px dashed #999; margin-top: 20px;&#125;.firstTitle &#123; font-size: 16px; color: #000;&#125;.secondTitle &#123; width: 40px; height: 40px; border: 1px solid rgb(0, 153, 255); border-radius: 6px; line-height: 40px; text-align: center; margin-top: 20px; font-size: 14px; display: inline-block; margin-right: 10px;&#125;&lt;/style&gt; 4.注意事项 group属性相同的话可以互相拖拽，故不想互相拖拽的话，要分开设置。比如我用:group=&quot;&#39;changeNum&#39;+index&quot;使每个框的数字互不干扰。 父组件传过来的数据不能直接双向绑定，可以克隆一下数据再绑定。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在react中实现打印功能]]></title>
    <url>%2Fblog%2F2019%2F10%2F14%2Freact-to-print%2F</url>
    <content type="text"><![CDATA[我们知道，window.print()可以调起打印功能，但是直接用window.print()如果直接打印的话，没有样式，而且默认打印的是整个网页的内容。解决的方法可以用iframe方式引入需要打印的区域，并把样式添加进去，然后把iframe标签定位到看不到的地方去。搜了一下，已经有人造好了轮子，react-to-print插件就是这么做的。 一.使用方法 下载 npm install --save react-to-print 引用 import ReactToPrint from &#39;react-to-print&#39;; 调用 123456789//触发按钮&lt;ReactToPrint trigger=&#123;() =&gt; &lt;a href=&quot;#&quot;&gt;点此打印&lt;/a&gt;&#125; content=&#123;() =&gt; this.componentRef&#125; /&gt; //打印内容 &lt;div ref=&#123;el =&gt; (this.componentRef = el)&#125;&gt; ....内容 &lt;div/&gt; 二.组件参数该组件接受以下参数（注意：?表示可选参数）： 名称 类型 描述 trigger function 返回React组件或HTML元素的函数 content function 返回组件参考值的函数。然后将该参考值的内容用于打印 copyStyles boolean? 将所有&lt;style&gt;和&lt;link type=&quot;stylesheet&quot; /&gt;标签从&lt;head&gt;父窗口内部复制到打印窗口。（默认值：true） onBeforeGetContent function? 在库收集页面内容之前触发的回调函数。返回void或Promise。可用于在打印之前更改页面上的内容。 onBeforePrint function? 打印前触发的回调功能。返回void或Promise。注意：此功能在打印之前立即运行，但在收集页面内容之后才运行。要在打印之前修改内容，请onBeforeGetContent改用。 onAfterPrint function? 打印后触发的回调功能 onPrintError function(errorLocation: string, error: Error)? 如果打印错误严重到无法继续打印，将调用的回调函数。目前仅限于onBeforeGetContent或中的Promise拒绝onBeforePrint。使用它尝试再次打印。errorLocation会告诉您Promise在哪个回调中被拒绝。 removeAfterPrint boolean? 执行操作后，卸下打印iframe。默认为false。 pageStyle string? 覆盖默认的打印窗口样式 bodyClass string? 传递给打印窗口主体的类]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端踩坑之数组拷贝]]></title>
    <url>%2Fblog%2F2019%2F06%2F25%2Fjs-array-clone%2F</url>
    <content type="text"><![CDATA[众所周知，在 JavaScript 中对象之间的赋值，只是拷贝对象的引用，也就是浅拷贝，不是真正意义上的拷贝，两个对象之间还会相互影响。然而，我一直忽略了一个问题，数组之间的拷贝会不会也有同样的问题呢？果不其然，当我再次用常用的 array.concat() 方法拷贝数组时，踩到坑了。当我改变一个数组里面对象属性的时候，另一个数组里的对象也跟着改变了。。。 数组的拷贝方法有很多，按结果来看就是浅拷贝和深拷贝两种。 一、直接赋值1let arr2 = arr1; 这种拷贝方法是浅拷贝，数组arr1和数组arr2共用同一内存，其中一个数组改变，另一个数组也会跟着改变。 二、使用 slice()，concat()，assign() 方法123let arr2 = arr1.slice(0);let arr3 = [].concat(arr1);let arr4 = Object.assign(&#123;&#125; , arr1); 这几种方法产生的效果是一样的。 若原数组中不存在引用类型，修改新数组，不会影响到原数组的值。 若原数组中存在引用类型，修改新数组，会影响到原数组的值 原因是这样拷贝数组中非引用类型的值属于深拷贝，引入类型的值属于浅拷贝。 三、深拷贝方法1. JSON复制法1let arr2 = JSON.parse(JSON.stringify(arr1)); 但是这种方式有一定的局限性，就是数组必须遵从JSON的格式，当遇到层级较深，且序列化数组不完全符合JSON格式时，使用JSON的方式进行深拷贝就会出现问题。 所有函数及原型成员都会被有意忽略，不体现在结果中。此外，值为 undefined 的任何属性也都会被跳过。结果中最终都是值为有效 JSON 数据类型的实例属性。 2. 使用递归1234567891011121314151617function deepClone(source) &#123; // 递归终止条件 if (!source || typeof source !== &apos;object&apos;) &#123; return source; &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key) &#123; if (source[key] &amp;&amp; typeof source[key] === &apos;object&apos;) &#123; targetObj[key] = deepClone(source[key]); &#125; else &#123; targetObj[key] = source[key]; &#125; &#125; &#125; return targetObj;&#125; 对于 Function 类型，这里是直接复制的，任然是共享一个内存地址。因为函数更多的是完成某些功能，对函数的更改可能就是直接重新赋值，一般情况下不考虑深拷贝。上面的深拷贝只是比较简单的实现，没有考虑很复杂的情况，比如： 其他引用类型：Function，Date，RegExp 的拷贝 对象中存在循环引用(Circular references)会导致调用栈溢出 通过闭包作用域来实现私有成员的这类对象不能真正的被拷贝。 3. 使用lodash库12import cloneDeep from &apos;lodash/cloneDeep&apos;; let arr2 = cloneDeep(arr1); 参考1.深入理解 JavaScript 对象和数组拷贝]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在iView中动态创建表格]]></title>
    <url>%2Fblog%2F2019%2F04%2F28%2Fabout-iview-table%2F</url>
    <content type="text"><![CDATA[最近在使用iView中的表格组件时，碰到许多坑和疑惑，仔细研究了一下table组件，发现官方文档讲的不是很清楚，本文将介绍并使用table组件，做一个动态创建表格的demo，效果如下图 一、在columns中写render函数查看官方文档可知，表格中主要的两个属性分别为columns和data。columns用来渲染列，data是渲染所用的数据，想在iView中插入标签，需要用它提供的render函数，这跟react的render差不多。 render函数的几个参数： h: Render函数的别名（全名 createElement） params： table 该行内容的对象，包含row（当前行对象）和index（当前行的序列号） props：设置创建的标签对象的属性 style：设置创建的标签对象的样式 on：为创建的标签绑定事件 二、如何写render函数1.插入Input123456789101112render: (h, &#123; row, index &#125;) =&gt; &#123; return h(&quot;Input&quot;, &#123; props: &#123; value: row.name &#125;, on: &#123; input: val =&gt; &#123; this.data[index].name = val; &#125; &#125; &#125;);&#125; 这是一个插入Input框的例子。 h渲染出&lt;input&gt;标签 prop设置其value为当前行的name on添加input方法，使当前行的name为输入的值2.插入Select 12345678910111213141516171819202122232425&#123; title: &quot;爱好&quot;, key: &quot;hobby&quot;, render: (h, &#123; row, index &#125;) =&gt; &#123; return h(&quot;Select&quot;, &#123; props: &#123; value: row.hobby &#125;, on: &#123; &apos;on-select&apos;: val =&gt; &#123; this.data[index].hobby = val; &#125; &#125; &#125;, this.options.map(item=&gt;&#123; return h(&apos;Option&apos;,&#123; props:&#123; value:item, label:item &#125; &#125;) &#125;) ); &#125; &#125;, 这是一个插入Select框的例子 将要嵌套的组件用花括号放在后面,option可通过map函数就可以代替v-for的渲染。 如果要嵌套多个组件，可以写成数组的形式。比如： 123456render: (h, params) =&gt; &#123; return h(&apos;div&apos;, [ h(&apos;Button&apos;), h(&apos;Button&apos;) ]); &#125; 三、一些常见的坑 插入Select组件的时候，如果table行数较少，会出现遮住下拉框的情况。解决方法：在table组件上加上样式overflow: visible。 Select组件的触发事件为on-change 需要用props设置初始值，否则值不会渲染到真正的当前行。 四、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;template&gt; &lt;div class=&quot;table&quot;&gt; &lt;Button class=&quot;button&quot; @click=&quot;add&quot;&gt;Add&lt;/Button&gt; &lt;Table :columns=&quot;columns&quot; :data=&quot;data&quot; class=&quot;table-fixbug&quot;&gt;&lt;/Table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;HelloWorld&quot;, data() &#123; return &#123; columns: [ &#123; type: &quot;selection&quot;, width: 60, align: &quot;center&quot; &#125;, &#123; title: &quot;姓名&quot;, key: &quot;name&quot;, render: (h, &#123; row, index &#125;) =&gt; &#123; return h(&quot;Input&quot;, &#123; props: &#123; value: row.name &#125;, on: &#123; input: val =&gt; &#123; this.data[index].name = val; &#125; &#125; &#125;); &#125; &#125;, &#123; title: &quot;爱好&quot;, key: &quot;hobby&quot;, render: (h, &#123; row, index &#125;) =&gt; &#123; return h(&quot;Select&quot;, &#123; props: &#123; value: row.hobby &#125;, on: &#123; &apos;on-select&apos;: val =&gt; &#123; this.data[index].hobby = val; &#125; &#125; &#125;, this.options.map(item=&gt;&#123; return h(&apos;Option&apos;,&#123; props:&#123; value:item, label:item &#125; &#125;) &#125;) ); &#125; &#125;, &#123; title: &quot;职业&quot;, key: &quot;job&quot;, render: (h, &#123; row, index &#125;) =&gt; &#123; return h(&quot;Input&quot;, &#123; props: &#123; value: row.job &#125;, on: &#123; input: val =&gt; &#123; this.data[index].job = val; &#125; &#125; &#125;); &#125; &#125;, &#123; title: &quot;operation&quot;, key: &quot;operation&quot;, render: (h, &#123; row, index &#125;) =&gt; &#123; return h( &quot;a&quot;, &#123; on: &#123; click: () =&gt; &#123; this.data.splice(index, 1); &#125; &#125; &#125;, &quot;Delete&quot; ); &#125; &#125; ], data: [ &#123; name: &quot;&quot;, hobby: &quot;&quot;, job: &quot;&quot; &#125; ], options:[&apos;电影&apos;,&apos;游戏&apos;,&apos;看书&apos;] &#125;; &#125;, methods: &#123; add() &#123; const addData = &#123; name: &quot;&quot;, hobby: &quot;&quot;, job: &quot;&quot; &#125;; this.data.push(addData); &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;.table &#123; text-align: left;&#125;.button &#123; margin-bottom: 20px;&#125;.table-fixbug&#123; overflow: visible;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一分钟搞懂npm install的参数]]></title>
    <url>%2Fblog%2F2019%2F03%2F27%2Fabout-npm-install%2F</url>
    <content type="text"><![CDATA[之前一直对 npm install 的两个参数 --save和 --save-dev 分不清楚，甚至觉得这两个是同一个命令，因此踩不少坑，于是研究了一下 npm install 常用的几个参数。 常用命令 npm install &lt;package_name&gt; 使用该命令会安装在当前目录下，但不会写入项目中的package.json。 npm install &lt;package_name&gt; --global (简写-g) 表示全局安装，一般来说会安装在系统预设的目录下。不会写入项目中的package.json。 展示全局包实际位置 npm root -g 修改全局包位置npm config set prefix &#39;目标目录&#39; npm install &lt;package_name&gt; --save (简写-S) 表示生产环境下安装，会安装到项目中的node_modules中，并写入package.json里面的dependencies npm install &lt;package_name&gt; --save-dev (简写-D) 表示开发环境下安装，会安装到项目中的node_modules中，并写入package.json里面的devDependencies 区别 安装位置的区别外 运行npm install初始化项目时 npm install &lt;package_name&gt;和npm install &lt;package_name&gt; --global命令安装的模块不会自动下载 npm install &lt;package_name&gt; --save 和npm install &lt;package_name&gt; --save-dev命令安装的模块会自动下载 运行npm install --production或者注明NODE_ENV变量值为production时 dependencies里的模块会自动下载 devDependencies里的模块不会自动下载 总结npm install &lt;package_name&gt;相当于安装一次性的模块，项目中一般不适用 npm install &lt;package_name&gt; -g一般用于全局node工具的安装 npm install &lt;package_name&gt; --save-dev一般用于项目中开发工具的安装，如mockjs、umi等 npm install &lt;package_name&gt; --save一般用于项目中必需依赖的安装，如react、antd等]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>nodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当我开始尝试用npm发布包]]></title>
    <url>%2Fblog%2F2019%2F03%2F25%2Fnpm-publish%2F</url>
    <content type="text"><![CDATA[最近前端文件总是要打包上传到服务器上，所以总在重复一个动作，npm run build生成dist文件夹，再压缩成zip文件，上传服务器，改文件名。于是我想着能不能找一个脚本，可以比较方便的完成这套动作。找了几个npm包都不太满意，于是想着自己写一个发布。 1.发布包的基本流程 编写模块123module.exports = function ()&#123; ...&#125;; 将这段代码保存为index.js; 初始化包描述文件1$ npm init npm通过提问式的交互诸葛填入选项，最后生成预览的包描述文件。确认后输入yes，此时会在目录下生产package.json文件。 注册包仓库账号1$ npm adduser 这也是一个提问式的交互，按顺序注册即可。 上传包1$ npm publish . 在这个过程中，npm会将目录打包为一个存档文件，然后上传到官方源仓库中。 更新包通过npm version &lt;update_type&gt;自动改变版本update_type为patch, minor, or major其中之一，分别表示补丁，小改，大改 2.发布包的一些坑 不能和已有的包的名字重名或太相近！ 为此我绞尽脑汁想了好几个名字，居然都不通过。 包名不能有大写字母/空格/下滑线! 进一步限制了可选的名字。 .gitignore里的文件会被忽略 如果项目里有不想上传的部分，可以写在.npmignore中，如果没有.npmignore文件，npm会寻找.gitignore文件，起同样作用。 只会上传dependencies里的依赖 我一直对npm install里的–save和–save-dev使用的比较混乱，所以一开始我的依赖装在devDependencies里，结果怎么都不起作用，原来是没有上传。对这两个参数傻傻分不清楚的同学,可以看这篇文章 一分钟搞懂npm install的参数。 3.关于deerpack正如文章开头所说，我写了一个小脚本，功能是将文件夹打包成zip文件，并且可以改名以及删除原文件夹。名字叫deerpack(点击名字可进入github查看使用方法)。为什么要叫这么奇怪的名字呢，还不是因为重复的包名太多了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>nodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的前端之路]]></title>
    <url>%2Fblog%2F2019%2F03%2F16%2Fmy-life%2F</url>
    <content type="text"><![CDATA[我并不是科班出身。大学没有选计算机专业，一度是我人生中最后悔的事情。实习的那年，不学无术的我，经历了社会狠狠的毒打。此时的我，一门心思想搞IT，于是找了一家IT学校。学校里只有前端和PHP，我想了想报了前端，培训了半年。不得不说，那是我最快乐的一段时光，还认识了我的好朋友，林。 欢乐时光总是短暂的，眨眼间就要开始找工作了。此时的我已经毕业半年了，来到了2018年初。来自各处的压力，让我心里焦急的很，满脑子都是赶紧上班赚钱。 一周的时间，我面试了四家公司，第二周收到了两个offer，略微思考了一下，我去了待遇和薪资好一点的那家。当时的我虽然学了一大堆乱七八糟的，也依葫芦画瓢做了几个项目，但是自己有几斤几两还是心理有数的。 上班第一天，领导就丢给了我一个项目，五十多张设计图，让我估个时间。我很慌，甚至不明白他说的切图是什么。对着电脑屏幕想了一上午，是拿刀切还是用ps切。问了问产品经理，他说就是做成网页，大概要15个工作日吧。我如是跟领导说，领导说不行，12个工作日搞定。当时我的心里一惊，心想，不会刚开始工作就要被辞了吧，感觉凉凉了。 打开编辑器，不知道从何开始，问了问对面的前端实习生，她说就这么写呗。。。后来，我只能硬着头皮开始了切图。不得不说，当时我的css真是太差了，页面完全是像搭积木打起来的。浮动，清除浮动，一块一块的堆起来。类名各种重复，代码真是烂到家了。一天下来，才做了首页的一个导航栏。 我深知照这个速度根本赶不上，压力山大，回家后继续码代码，一直干到睡觉，中午也不休息，边吃饭边切图。深知生活的压力，轻轻松松就能让人拼死拼活。高三的时候我要是这么努力，早就考上名牌大学了。 就这样，我甚至提前2天完成了项目。其实是中间有三天清明节放假，我还在干活。领导对我很满意，虽然代码一团糟，但是做出的效果跟设计图一样的就行了。于是又给了我一个新项目，90多张设计图，关键还是设计一边出图，我一边切图，考虑到同步问题，让我在设计后面晚一个星期完成。 熟练后，我的速度赶上了设计。在等待设计出图的时候，我终于有时间学一点东西了。我发现公司的前端主要是写样式，偶尔用用jquery写点交互，数据渲染全用的php。于是我打算先把css精进一下。在网上我看到了张鑫旭博客，学了不少东西，然后我买了一本他的书《css世界》。 这本书让我对css底层的一些东西有了深层次的理解，还有不少奇思淫巧，语言也是通俗易懂，就是有些比喻太长了，有些冗长。总体而言是一本非常不错的书。不过这本书讲的都是css2.1之前的东西，希望作者再出一本关于css3的书吧，毕竟弹性盒是真的好用啊。 参考了张鑫旭样式分开的想法，我自己也写了一个常用的css库–mycss，这样写样式特别快，效率提高了不少。 话说回来，我在公司已经呆了两个月了，由于表现良好，提前转了正，工资也涨了一点点。可我并没有开心，因为在同期的学生中，我并不算优秀。领导许诺我，三个月后按照工作量来调薪，并制定了各个项目的分数。我心里暗暗高兴，照这个进度下去，铁定涨薪啊，还不少呢。 傻傻的我工作更加卖力，虽然没怎么加班，但是效率极高，记得有一次，公司的伙伴公司缺人，派我去帮忙，三天后，公司领导似乎感觉到不对劲，一直催促我回去，于是我快马加鞭，短短一周便帮他们完成了项目。回去后，领导喜出望外，又给了我一堆项目。当时的我反而很高兴，反正我做的越多，到时候涨薪就越多啊。结果不知道是不是公司陈年累计的项目都做完了，还是设计人手不够了，我没有项目做了。 领导也不是傻子，自然不会让我闲着，派了一个老员工教我php，让我边做边学。记得当时用的Laravel框架，现在看跟前端好多脚手架很像呢。公司前端的技术栈少的可怜，基本上就是个切图仔，偶尔用Jquery做做交互。我深知继续下去只能做一个井底之蛙，虽然只干了半年，但还是开始谋划着跳槽，一个月内投了不少简历，结果只有两家让我去面试。第一家没准备好，回答的一塌糊涂，没戏。第二家是个规模不小的外包，让我先去华为面试，第一次踏入大公司的门，心里还有些激动。所幸面试官并没有为难我，通过了。 辞职的时候，心情很复杂，在公司过得也很开心，领导对我也不错，觉得有点对不起这个把我拉扯大的起点。最后鼓起勇气跟领导说了，领导刚开始很讶异，后来似乎也想明白了些什么，问我找到新工作了吗，我回答是。他笑了笑，着急走吗？我淡淡的说，尽快吧。我把手上两个项目完成后就离开了。 离开后的第二天，我来到了新公司。一进来，就感觉到了自己的渺小，不仅人多，大牛也很多。在茫茫人海中，我只是一颗小小的螺丝钉。从头开始吧，我对自己说。这次又踏上了新的征程。 我的目标是星辰大海。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[antd中使用upload改成点击保存后上传文件]]></title>
    <url>%2Fblog%2F2019%2F03%2F09%2FInAntdSaveAndUploadFile%2F</url>
    <content type="text"><![CDATA[公司项目的UI框架用的是antd，最近有一个上传jar包的需求，需要点击保存后，和表单一起上传到一个地址。但Upload组件默认是选择文件后立即上传文件。如何实现呢？ 一、双向绑定表单1234567891011 &lt;Form.Item label="file"&gt; &#123;getFieldDecorator('file', &#123; rules: [&#123;required: true&#125;] &#125;)( &lt;Upload beforeUpload=&#123;beforeUpload&#125;&gt; &lt;Button&gt; &lt;Icon type="upload" /&gt; Click to Upload &lt;/Button&gt; &lt;/Upload&gt;, )&#125;&lt;/Form.Item&gt; 二、阻止默认提交beforeUpload 返回 false 后，可以手动上传文件。123const beforeUpload = (file) =&gt; &#123; return false; &#125;, 三、创建一个formData对象实例1const formData = new FormData(); 四、把表单里的数据添加进去12const data = props.form.getFieldsValue();formData.append('file',data.file); 五、发送数据到后台记得设置Content-Type12345678910111213 Axios(&#123; headers: &#123; 'Content-Type': 'multipart/form-data' &#125;, method: 'post', data: formData, url: 'http://...' &#125;).then(res =&gt; &#123; console.log('res', res) &#125;, err =&gt; &#123; console.log('err', err) &#125;)&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ant-design</tag>
      </tags>
  </entry>
</search>
